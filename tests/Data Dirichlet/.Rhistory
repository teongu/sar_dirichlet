}
logit_normal_model(data_test, 1, W_mat)
data_test <- data_arctic[, c('depth_scaled', 'sand', 'silt', 'clay')]
logit_normal_model <- function(inputData, n_features, W_mat) {
data <- inputData[,1:n_features]
data <- cbind(data, lr(inputData[,(n_features+1):ncol(inputData)]))
print(data)
W <- mat2listw(W_mat, style="W")
list_rhos <- c()
list_coefficients <- c()
for (i in (n_features+1):ncol(inputData)){
formula <- as.formula(paste0(colnames(data)[i], " ~ ", paste0(names(data)[1:n_features], collapse = " + "), " - 1"))
mod <- lagsarlm(formula, data=data,listw=W)
append(list_rhos,mod$rho)
append(list_coefficients,mod$coefficients)
}
return(list(list_rhos, list_coefficients))
}
logit_normal_model(data_test, 1, W_mat)
logit_normal_model <- function(inputData, n_features, W_mat) {
data <- inputData[,1:n_features]
data <- cbind(data, lr(inputData[,(n_features+1):ncol(inputData)]))
W <- mat2listw(W_mat, style="W")
list_rhos <- c()
list_coefficients <- c()
for (i in (n_features+1):ncol(inputData)){
formula <- as.formula(paste0(colnames(data)[i], " ~ ", paste0(names(data)[1:n_features], collapse = " + "), " - 1"))
mod <- lagsarlm(formula, data=data,listw=W)
list_rhos <- append(list_rhos,mod$rho)
list_coefficients <- append(list_coefficients,mod$coefficients)
}
return(list(list_rhos, list_coefficients))
}
logit_normal_model(data_test, 1, W_mat)
mod1$coefficients
X <- read.csv("maupiti_X.csv", sep=" ")
View(X)
X <- read.csv("maupiti_X.csv", sep=",")
Y <- read.csv("maupiti_Y.csv", sep=",")
W_mat <- as.matrix(read.csv("maupiti_W.csv", sep=",", header=FALSE))
View(W_mat)
View(W_mat)
dim(W_mat)
dim(X)
W_mat <- as.matrix(read.csv("maupiti_W.csv", sep=","))
dim(W_mat)
View(X)
View(X)
X <- read.csv("maupiti_X.csv", sep=",", header="None")
X <- read.csv("maupiti_X.csv", sep=",", header=FALSE)
Y <- read.csv("maupiti_Y.csv", sep=",", header=FALSE)
W_mat <- as.matrix(read.csv("maupiti_W.csv", sep=",", header=FALSE))
W <- mat2listw(W_mat, style="W")
library(readr)
library(spdep)
library(spatialreg)
library(MLmetrics)
lr <- function(x) {
log(x / rowMeans(x))
}
lr_inv <- function(x) {
exp(x) / rowSums(exp(x))
}
W <- mat2listw(W_mat, style="W")
X_scaled <- read.csv("maupiti_X.csv", sep=",", header=FALSE)
View(W_mat)
W <- mat2listw(W_mat, style="W")
W_mat <- as.matrix(read.csv("maupiti_W_no_zeros.csv", sep=",", header=FALSE))
W <- mat2listw(W_mat, style="W")
lr_Y <- lr(Y)
lm_list <- list()
for (i in seq_along(lr_Y)) {
# Fit a linear model for response variable i using the features in X
lm_model <- lagsarlm(lr_Y[, i] ~ . - 1, data = X_scaled, listw=W)
# Store the linear model in the list
lm_list[[i]] <- lm_model
}
lm_list[[1]]$coefficients
for (i in seq_along(lm_list)) {
print(i)
}
lm_list
dim(lr_Y)
Xbeta1 <- as.matrix(X_scaled) %*% as.matrix(lm_list[[1]]$coefficients)
Xbeta2 <- as.matrix(X_scaled) %*% as.matrix(lm_list[[2]]$coefficients)
Xbeta3 <- as.matrix(X_scaled) %*% as.matrix(lm_list[[3]]$coefficients)
Xbeta4 <- as.matrix(X_scaled) %*% as.matrix(lm_list[[4]]$coefficients)
rho = mean(c(lm_list[[1]]$rho, lm_list[[2]]$rho, lm_list[[3]]$rho, lm_list[[4]]$rho))
lm_list[[1]]$rho
lm_list[[2]]$rho
rho
Minv = solve( diag(nrow(W_mat)) - rho*W_mat )
pred <- data.frame(c1 = Minv %*% as.matrix(Xbeta1),
c2 = Minv %*% as.matrix(Xbeta2),
c3 = Minv %*% as.matrix(Xbeta3),
c4 = Minv %*% as.matrix(Xbeta4))
pred_final <- lr_inv(pred)
cos_similarity <- function(x1, x2) {
mean(sapply(seq_len(nrow(x1)), function(i) {
sum(x1[i,] * x2[i,]) / (sqrt(sum(x1[i,]^2)) * sqrt(sum(x2[i,]^2)))
}))
}
n = 2301
mse_values <- numeric()
for (i in 1:ncol(Y)) {
# Compute MSE for the current column
mse_values[i] <- MSE(pred_final[, i], Y[, i])
}
# R2
mean(diag(cor(pred_final, Y) ^ 2))
# RMSE
sqrt(mean(mse_values))
# cos similarity
cos_similarity(Y, pred_final)
# cross-entropy
sum(Y * log(pred_final)) / n
normalize <- function(x) {
(x - mean(x)) / sd(x)
}
Y_occitanie <- read.csv("occitanie/Y_occitanie.csv", sep=";")
X_occitanie <- read.csv("occitanie/X_occitanie_bis.csv", sep=";")
X_occitanie <- X_occitanie[, -1]
W_mat <- as.matrix(read.csv("occitanie/W_elections_5nn.csv", sep=" ", header=FALSE))
W <- mat2listw(W_mat, style="W")
X_scaled <- as.data.frame(lapply(X_occitanie, normalize))
# we drop columns age_65 and foreign that cause aliased variables error
X_scaled <- subset(X_scaled, select = -c(`age_65`, `foreign`))
lr_Y <- lr(Y_occitanie)
lm_list <- list()
for (i in seq_along(lr_Y)) {
# Fit a linear model for response variable i using the features in X
lm_model <- lagsarlm(lr_Y[, i] ~ . - 1, data = X_scaled, listw=W)
# Store the linear model in the list
lm_list[[i]] <- lm_model
}
Xbeta1 <- as.matrix(X_scaled) %*% as.matrix(lm_list[[1]]$coefficients)
Xbeta2 <- as.matrix(X_scaled) %*% as.matrix(lm_list[[2]]$coefficients)
Xbeta3 <- as.matrix(X_scaled) %*% as.matrix(lm_list[[3]]$coefficients)
rho = mean(c(lm_list[[1]]$rho, lm_list[[2]]$rho, lm_list[[3]]$rho))
Minv = solve( diag(nrow(W_mat)) - rho*W_mat )
Minv %*% as.matrix(Xbeta1)
pred <- data.frame(left = Minv %*% as.matrix(Xbeta1),
right = Minv %*% as.matrix(Xbeta2),
other = Minv %*% as.matrix(Xbeta3))
pred_final <- lr_inv(pred)
cos_similarity <- function(x1, x2) {
mean(sapply(seq_len(nrow(x1)), function(i) {
sum(x1[i,] * x2[i,]) / (sqrt(sum(x1[i,]^2)) * sqrt(sum(x2[i,]^2)))
}))
}
n = 207
mse_values <- numeric()
for (i in 1:ncol(Y_occitanie)) {
# Compute MSE for the current column
mse_values[i] <- MSE(pred_final[, i], Y_occitanie[, i])
}
# R2
mean(diag(cor(pred_final, Y_occitanie) ^ 2))
# RMSE
sqrt(mean(mse_values))
# cos similarity
cos_similarity(Y_occitanie, pred_final)
# cross-entropy
sum(Y_occitanie * log(pred_final)) / n
library(readr)
library(spdep)
library(spatialreg)
library(MLmetrics)
lr <- function(x) {
log(x / rowMeans(x))
}
lr_inv <- function(x) {
exp(x) / rowSums(exp(x))
}
data_arctic <- read_csv("ArcticLake.csv")
X <- as.data.frame(data_arctic$depth)
Y <- as.data.frame(data_arctic[, c('sand', 'silt', 'clay')])
W_mat <- as.matrix(read_csv("W_arctic_cont.csv"))
W <- mat2listw(W_mat, style="W")
data_arctic$depth_scaled <- (data_arctic$depth-mean(data_arctic$depth))/sd(data_arctic$depth)
lr_Y <- lr(Y)
colnames(lr_Y) <- c("sand_lr", "silt_lr", "clay_lr")
data_arctic <- cbind(data_arctic, lr_Y)
data_arctic[i]
data_arctic[2]
data_arctic[2,]
training_data <- data_arctic[-2, ]
mod1 <- lagsarlm(sand_lr ~ depth_scaled - 1, data=training_data, listw=W)
W[-2, -2]
W[-2,]
W[[-2,-2]]
W
W_mat[-2]
W_mat[-2,-2]
training_data <- data_arctic[-2, ]
W_mat_training <- W_mat[-2, -2]
training_W <- mat2listw(W_mat_training, style="W")
mod1 <- lagsarlm(sand_lr ~ depth_scaled - 1, data=training_data, listw=training_W)
mod2 <- lagsarlm(silt_lr ~ depth_scaled - 1, data=training_data, listw=training_W)
mod3 <- lagsarlm(clay_lr ~ depth_scaled - 1, data=training_data, listw=training_W)
Xbeta1 <- mod1$coefficients[1]*data_arctic[2,]$depth_scaled
Xbeta2 <- mod2$coefficients[1]*data_arctic[2,]$depth_scaled
Xbeta3 <- mod3$coefficients[1]*data_arctic[2,]$depth_scaled
Xbeta1
rho = mean(c(mod1$rho, mod2$rho, mod3$rho))
Minv = solve( diag(nrow(W_mat_training)) - rho*W_mat_training )
Minv %*% Xbeta1
# Iterate over each row index
for (i in 1:nrow(data_arctic)) {
# Exclude the i-th row
training_data <- data_arctic[-i, ]
W_mat_training <- W_mat[-i, -i]
training_W <- mat2listw(W_mat_training, style="W")
mod1 <- lagsarlm(sand_lr ~ depth_scaled - 1, data=training_data, listw=training_W)
mod2 <- lagsarlm(silt_lr ~ depth_scaled - 1, data=training_data, listw=training_W)
mod3 <- lagsarlm(clay_lr ~ depth_scaled - 1, data=training_data, listw=training_W)
Xbeta1 <- mod1$coefficients[1]*data_arctic$depth_scaled
Xbeta2 <- mod2$coefficients[1]*data_arctic$depth_scaled
Xbeta3 <- mod3$coefficients[1]*data_arctic$depth_scaled
rho = mean(c(mod1$rho, mod2$rho, mod3$rho))
Minv = solve( diag(nrow(W_mat)) - rho*W_mat )
pred <- data.frame(sand = Minv * Xbeta1,
silt = Minv * Xbeta2,
clay = Minv * Xbeta3)
list_pred[i] <- pred[i]
}
list_pred <- list()
# Iterate over each row index
for (i in 1:nrow(data_arctic)) {
# Exclude the i-th row
training_data <- data_arctic[-i, ]
W_mat_training <- W_mat[-i, -i]
training_W <- mat2listw(W_mat_training, style="W")
mod1 <- lagsarlm(sand_lr ~ depth_scaled - 1, data=training_data, listw=training_W)
mod2 <- lagsarlm(silt_lr ~ depth_scaled - 1, data=training_data, listw=training_W)
mod3 <- lagsarlm(clay_lr ~ depth_scaled - 1, data=training_data, listw=training_W)
Xbeta1 <- mod1$coefficients[1]*data_arctic$depth_scaled
Xbeta2 <- mod2$coefficients[1]*data_arctic$depth_scaled
Xbeta3 <- mod3$coefficients[1]*data_arctic$depth_scaled
rho = mean(c(mod1$rho, mod2$rho, mod3$rho))
Minv = solve( diag(nrow(W_mat)) - rho*W_mat )
pred <- data.frame(sand = Minv * Xbeta1,
silt = Minv * Xbeta2,
clay = Minv * Xbeta3)
list_pred[i] <- pred[i]
}
2+2
list_pred
View(list_pred)
list_pred <- data.frame()
# Iterate over each row index
for (i in 1:nrow(data_arctic)) {
# Exclude the i-th row
training_data <- data_arctic[-i, ]
W_mat_training <- W_mat[-i, -i]
training_W <- mat2listw(W_mat_training, style="W")
mod1 <- lagsarlm(sand_lr ~ depth_scaled - 1, data=training_data, listw=training_W)
mod2 <- lagsarlm(silt_lr ~ depth_scaled - 1, data=training_data, listw=training_W)
mod3 <- lagsarlm(clay_lr ~ depth_scaled - 1, data=training_data, listw=training_W)
Xbeta1 <- mod1$coefficients[1]*data_arctic$depth_scaled
Xbeta2 <- mod2$coefficients[1]*data_arctic$depth_scaled
Xbeta3 <- mod3$coefficients[1]*data_arctic$depth_scaled
rho = mean(c(mod1$rho, mod2$rho, mod3$rho))
Minv = solve( diag(nrow(W_mat)) - rho*W_mat )
pred <- data.frame(sand = Minv * Xbeta1,
silt = Minv * Xbeta2,
clay = Minv * Xbeta3)
list_pred[i] <- pred[i]
}
2+2
warnings()
list_pred <- list()
# Iterate over each row index
for (i in 1:nrow(data_arctic)) {
# Exclude the i-th row
training_data <- data_arctic[-i, ]
W_mat_training <- W_mat[-i, -i]
training_W <- mat2listw(W_mat_training, style="W")
mod1 <- lagsarlm(sand_lr ~ depth_scaled - 1, data=training_data, listw=training_W)
mod2 <- lagsarlm(silt_lr ~ depth_scaled - 1, data=training_data, listw=training_W)
mod3 <- lagsarlm(clay_lr ~ depth_scaled - 1, data=training_data, listw=training_W)
Xbeta1 <- mod1$coefficients[1]*data_arctic$depth_scaled
Xbeta2 <- mod2$coefficients[1]*data_arctic$depth_scaled
Xbeta3 <- mod3$coefficients[1]*data_arctic$depth_scaled
rho = mean(c(mod1$rho, mod2$rho, mod3$rho))
Minv = solve( diag(nrow(W_mat)) - rho*W_mat )
pred <- data.frame(sand = Minv * Xbeta1,
silt = Minv * Xbeta2,
clay = Minv * Xbeta3)
list_pred[i] <- pred[i]
}
list_pred[i]
list_pred[[i]]
list_pred(i)
list_pred[i]
View(list_pred)
pred
pred[i]
pred[i,]
pred[,i]
pred[i,]
View(pred)
library(readr)
library(spdep)
library(spatialreg)
library(MLmetrics)
lr <- function(x) {
log(x / rowMeans(x))
}
lr_inv <- function(x) {
exp(x) / rowSums(exp(x))
}
data_arctic <- read_csv("ArcticLake.csv")
X <- as.data.frame(data_arctic$depth)
Y <- as.data.frame(data_arctic[, c('sand', 'silt', 'clay')])
W_mat <- as.matrix(read_csv("W_arctic_cont.csv"))
W <- mat2listw(W_mat, style="W")
data_arctic$depth_scaled <- (data_arctic$depth-mean(data_arctic$depth))/sd(data_arctic$depth)
lr_Y <- lr(Y)
colnames(lr_Y) <- c("sand_lr", "silt_lr", "clay_lr")
data_arctic <- cbind(data_arctic, lr_Y)
list_pred <- list()
# Iterate over each row index
for (i in 1:nrow(data_arctic)) {
# Exclude the i-th row
training_data <- data_arctic[-i, ]
W_mat_training <- W_mat[-i, -i]
training_W <- mat2listw(W_mat_training, style="W")
mod1 <- lagsarlm(sand_lr ~ depth_scaled - 1, data=training_data, listw=training_W)
mod2 <- lagsarlm(silt_lr ~ depth_scaled - 1, data=training_data, listw=training_W)
mod3 <- lagsarlm(clay_lr ~ depth_scaled - 1, data=training_data, listw=training_W)
Xbeta1 <- mod1$coefficients[1]*data_arctic$depth_scaled
Xbeta2 <- mod2$coefficients[1]*data_arctic$depth_scaled
Xbeta3 <- mod3$coefficients[1]*data_arctic$depth_scaled
rho = mean(c(mod1$rho, mod2$rho, mod3$rho))
Minv = solve( diag(nrow(W_mat)) - rho*W_mat )
pred <- data.frame(sand = Minv * Xbeta1,
silt = Minv * Xbeta2,
clay = Minv * Xbeta3)
list_pred[i] <- pred[i]
}
View(list_pred)
training_data <- data_arctic[-2, ]
W_mat_training <- W_mat[-2, -2]
training_W <- mat2listw(W_mat_training, style="W")
mod1 <- lagsarlm(sand_lr ~ depth_scaled - 1, data=training_data, listw=training_W)
mod2 <- lagsarlm(silt_lr ~ depth_scaled - 1, data=training_data, listw=training_W)
mod3 <- lagsarlm(clay_lr ~ depth_scaled - 1, data=training_data, listw=training_W)
Xbeta1 <- mod1$coefficients[1]*data_arctic$depth_scaled
Xbeta2 <- mod2$coefficients[1]*data_arctic$depth_scaled
Xbeta3 <- mod3$coefficients[1]*data_arctic$depth_scaled
rho = mean(c(mod1$rho, mod2$rho, mod3$rho))
Minv = solve( diag(nrow(W_mat)) - rho*W_mat )
pred <- data.frame(sand = Minv * Xbeta1,
silt = Minv * Xbeta2,
clay = Minv * Xbeta3)
pred[i]
pred
dim(Minv)
dim(Xbeta1)
Xbeta1
pred <- data.frame(sand = Minv %*% Xbeta1,
silt = Minv %*% Xbeta2,
clay = Minv %*% Xbeta3)
pred[i]
pred
pred[i,]
list_pred <- list()
# Iterate over each row index
for (i in 1:nrow(data_arctic)) {
# Exclude the i-th row
training_data <- data_arctic[-i, ]
W_mat_training <- W_mat[-i, -i]
training_W <- mat2listw(W_mat_training, style="W")
mod1 <- lagsarlm(sand_lr ~ depth_scaled - 1, data=training_data, listw=training_W)
mod2 <- lagsarlm(silt_lr ~ depth_scaled - 1, data=training_data, listw=training_W)
mod3 <- lagsarlm(clay_lr ~ depth_scaled - 1, data=training_data, listw=training_W)
Xbeta1 <- mod1$coefficients[1]*data_arctic$depth_scaled
Xbeta2 <- mod2$coefficients[1]*data_arctic$depth_scaled
Xbeta3 <- mod3$coefficients[1]*data_arctic$depth_scaled
rho = mean(c(mod1$rho, mod2$rho, mod3$rho))
Minv = solve( diag(nrow(W_mat)) - rho*W_mat )
pred <- data.frame(sand = Minv %*% Xbeta1,
silt = Minv %*% Xbeta2,
clay = Minv %*% Xbeta3)
list_pred[i] <- pred[i]
}
list_pred[i]
list_pred[1]
View(list_pred)
list_pred[[1]]
list_pred[,1]
list_pred <- matrix(nrow = 0, ncol = 3)
# Iterate over each row index
for (i in 1:nrow(data_arctic)) {
# Exclude the i-th row
training_data <- data_arctic[-i, ]
W_mat_training <- W_mat[-i, -i]
training_W <- mat2listw(W_mat_training, style="W")
mod1 <- lagsarlm(sand_lr ~ depth_scaled - 1, data=training_data, listw=training_W)
mod2 <- lagsarlm(silt_lr ~ depth_scaled - 1, data=training_data, listw=training_W)
mod3 <- lagsarlm(clay_lr ~ depth_scaled - 1, data=training_data, listw=training_W)
Xbeta1 <- mod1$coefficients[1]*data_arctic$depth_scaled
Xbeta2 <- mod2$coefficients[1]*data_arctic$depth_scaled
Xbeta3 <- mod3$coefficients[1]*data_arctic$depth_scaled
rho = mean(c(mod1$rho, mod2$rho, mod3$rho))
Minv = solve( diag(nrow(W_mat)) - rho*W_mat )
pred <- data.frame(sand = Minv %*% Xbeta1,
silt = Minv %*% Xbeta2,
clay = Minv %*% Xbeta3)
list_pred <- rbind(list_pred, pred)
}
list_pred <- matrix(nrow = 0, ncol = 3)
# Iterate over each row index
for (i in 1:nrow(data_arctic)) {
# Exclude the i-th row
training_data <- data_arctic[-i, ]
W_mat_training <- W_mat[-i, -i]
training_W <- mat2listw(W_mat_training, style="W")
mod1 <- lagsarlm(sand_lr ~ depth_scaled - 1, data=training_data, listw=training_W)
mod2 <- lagsarlm(silt_lr ~ depth_scaled - 1, data=training_data, listw=training_W)
mod3 <- lagsarlm(clay_lr ~ depth_scaled - 1, data=training_data, listw=training_W)
Xbeta1 <- mod1$coefficients[1]*data_arctic$depth_scaled
Xbeta2 <- mod2$coefficients[1]*data_arctic$depth_scaled
Xbeta3 <- mod3$coefficients[1]*data_arctic$depth_scaled
rho = mean(c(mod1$rho, mod2$rho, mod3$rho))
Minv = solve( diag(nrow(W_mat)) - rho*W_mat )
pred <- data.frame(sand = Minv %*% Xbeta1,
silt = Minv %*% Xbeta2,
clay = Minv %*% Xbeta3)
list_pred <- rbind(list_pred, pred[i])
}
pred
pred[i]
pred[i,]
list_pred <- matrix(nrow = 0, ncol = 3)
# Iterate over each row index
for (i in 1:nrow(data_arctic)) {
# Exclude the i-th row
training_data <- data_arctic[-i, ]
W_mat_training <- W_mat[-i, -i]
training_W <- mat2listw(W_mat_training, style="W")
mod1 <- lagsarlm(sand_lr ~ depth_scaled - 1, data=training_data, listw=training_W)
mod2 <- lagsarlm(silt_lr ~ depth_scaled - 1, data=training_data, listw=training_W)
mod3 <- lagsarlm(clay_lr ~ depth_scaled - 1, data=training_data, listw=training_W)
Xbeta1 <- mod1$coefficients[1]*data_arctic$depth_scaled
Xbeta2 <- mod2$coefficients[1]*data_arctic$depth_scaled
Xbeta3 <- mod3$coefficients[1]*data_arctic$depth_scaled
rho = mean(c(mod1$rho, mod2$rho, mod3$rho))
Minv = solve( diag(nrow(W_mat)) - rho*W_mat )
pred <- data.frame(sand = Minv %*% Xbeta1,
silt = Minv %*% Xbeta2,
clay = Minv %*% Xbeta3)
list_pred <- rbind(list_pred, pred[i,])
}
list_pred
cos_similarity <- function(x1, x2) {
mean(sapply(seq_len(nrow(x1)), function(i) {
sum(x1[i,] * x2[i,]) / (sqrt(sum(x1[i,]^2)) * sqrt(sum(x2[i,]^2)))
}))
}
n = 39
mse_values <- numeric()
for (i in 1:ncol(Y)) {
# Compute MSE for the current column
mse_values[i] <- MSE(pred_final[, i], Y[, i])
}
list_pred[0]
mse_values <- numeric()
for (i in 1:ncol(Y)) {
# Compute MSE for the current column
mse_values[i] <- MSE(list_pred[, i], Y[, i])
}
mse_values
# R2
mean(diag(cor(list_pred, Y) ^ 2))
# RMSE
sqrt(mean(mse_values))
# cos similarity
cos_similarity(Y, list_pred)
# cross-entropy
sum(Y * log(list_pred)) / n
list_pred
pred_final <- lr_inv(list_pred)
n = 39
mse_values <- numeric()
for (i in 1:ncol(Y)) {
# Compute MSE for the current column
mse_values[i] <- MSE(list_pred[, i], Y[, i])
}
# R2 = 0.4270109
mean(diag(cor(pred_finale, Y) ^ 2))
# R2 = 0.4270109
mean(diag(cor(pred_final, Y) ^ 2))
# RMSE = 0.8241923
sqrt(mean(mse_values))
# cos similarity = 0.2292747
cos_similarity(Y, pred_final)
# cross-entropy
sum(Y * log(pred_final)) / n
View(pred_final)
mse_values <- numeric()
for (i in 1:ncol(Y)) {
# Compute MSE for the current column
mse_values[i] <- MSE(pred_final[, i], Y[, i])
}
# RMSE = 0.8241923
sqrt(mean(mse_values))
# cos similarity = 0.2292747
cos_similarity(Y, pred_final)
# cross-entropy
sum(Y * log(pred_final)) / n
